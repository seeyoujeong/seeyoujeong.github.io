---
title: JS, TS랑 비교하며 Rust 공부하기 (6)
excerpt: JS, TS랑 비교하면서 Rust를 공부하고 정리한 글
publishDate: '09 20 2025'
tags:
  - rust
seo:
  title: JS, TS랑 비교하며 Rust 공부하기 (6)
  description: JS, TS랑 비교하면서 Rust를 공부하고 정리한 글
---

## 에러 처리

러스트에는 `try...catch`문이 없고 `Result`나 `panic!`을 사용하여 에러 처리를 한다.  
`Result<T, E>` 열거형과 배리언트들(`Ok(T)`, `Err(E)`)은 프렐루드로부터 가져와진다.  
에러 처리를 하지 않고 프로그램을 강제 종료시키고 싶다면 `panic!`매크로를 사용하면 된다.  
기본적으로 실패할지도 모르는 함수를 정의할 때는 `Result`나 `Option` 를 반환하고, 프로토타입이나 테스트 같은 상황에서는 패닉을 일으키는게 좋다.

```rust
use std::fs::File;

let greeting_file_result = File::open("hello.txt");

let greeting_file = match greeting_file_result {
    Ok(file) => file,
    Err(error) => panic!("Problem opening the file: {:?}", error),
};
```

### `unwrap`과 `expect`메서드

`unwrap`과 `expect`메서드를 통해 `Result<T, E>` 타입을 짧게 처리할 수 있다.  
`unwrap`메서드는 `Result`값이 `Ok` 배리언트라면 `Ok` 내의 값을 반환하고, `Err`배리언트라면 `panic!`매크로를 호출한다.  
`expect`메서드는 `unwrap`메서드와 비슷하지만 다른 부분은 매개변수를 통해 에러 메시지를 지정해 줄 수 있다.  
`Err`배리언트가 나올 수 없다고 확신하는 경우에 두 메서드를 쓰는게 좋다.

```rust
use std::fs::File;

let greeting_file = File::open("hello.txt").unwrap();

let greeting_file = File::open("hello.txt")
    .expect("hello.txt should be included in this project");
```

### `?` 연산자

`?`연산자는 함수를 호출하는 코드 쪽으로 `Result`나 `Option` 열거형을 반환하는 에러 전파 패턴을 쉽게 처리할 수 있게 해준다.  
`?`연산자는 연산자가 사용된 함수의 반환 타입에 정의된 에러 타입으로 변환되기 때문에 호환 가능한 타입을 가진 함수에서만 사용할 수 있다. 예제 코드에서 보면 `File::open`과 `read_to_string`은 `Err(io::Error)`를 반환하기 때문에 `?`연산자를 쓸 수 있다.

```rust
// ? 연산자 없이 에러 전파

use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

```rust
// ? 연산자 사용한 에러 전파

use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)

    // 더 짧은 버전
    // let mut username = String::new();
    // File::open("hello.txt")?.read_to_string(&mut username)?;
    // Ok(username)
}
```

---

## 제네릭 타입

TS의 제네릭을 알고 있다면 어렵지않게 이해할 수 있다.  
제네릭을 통해 함수 시그니처나 구조체의 아이템에 다양한 구체적 데이터 타입을 사용할 수 있도록 정의할 수 있다.  
제네릭은 구체 타입이 한 번 정해지면 해당 인스턴스에서는 다른 타입을 받을 수 없다.  
러스트에서는 타입 이름을 지어줄 때는 대문자로 시작하는 낙타 표기법을 따르고, 타입 매개변수의 이름은 짧게 짓는 것이 관례이기 때문에, 대부분의 러스트 프로그래머는 `T`를 사용한다.  
러스트는 컴파일 타임에 제네릭을 사용하는 코드를 구체 타입으로 채워진 코드로 바꾸기 때문에 제네릭을 사용한다고 해서 느려지지 않는다.

### 제네릭 함수 정의

함수 시그니처와 본문에 제네릭 타입을 갖도록 정의할 수 있다.

```rust
fn largest<T>(list: &[T]) -> &T { ... }
```

### 제네릭 구조체 정의

구조체 필드에 제네릭 타입을 갖도록 정의할 수 있다.

```rust
struct Point<T, U> {
    x: T,
    y: U,
}
```

### 제네릭 열거형 정의

열거형의 배리언트에 제네릭 타입을 갖도록 정의할 수 있다.

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### 제네릭 메서드 정의

구조체나 열거형에 메서드를 구현할 때도 제네릭 타입을 갖도록 정의할 수 있다.  
구조체 정의에 선언된 제네릭 매개변수명과는 다른 제네릭 매개변수명을 사용할 수 있지만 같은 이름을 사용하는 것이 관례이다.

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

특정 타입의 메서드를 정의할 때 제네릭 타입에 대한 제약을 지정할 수 있다.  
특정 타입으로 정의한다고 해서 기존 메서드와 동일한 이름을 가진 메서드는 정의할 수 없다.

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }

    fn x(&self) -> &f32 { // error
        &self.x
    }
}
```

구조체 정의에 사용한 제네릭 타입 매개변수와 구조체의 메서드 시그니처에 사용하는 제네릭 타입 매개변수는 다르게 지정할 수 있다.

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

let p1 = Point { x: 5, y: 10.4 };
let p2 = Point { x: "Hello", y: 'c' };

let p3 = p1.mixup(p2);

println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
```
